###############################################################################
 #
 # Copyright (C) 2022-2023 Maxim Integrated Products, Inc. (now owned by
 # Analog Devices, Inc.),
 # Copyright (C) 2023-2024 Analog Devices, Inc.
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
 # You may obtain a copy of the License at
 #
 #     http://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 #
 ##############################################################################

import math
import struct
import time
import sys
import comManager
import image as image_saver

if len(sys.argv) == 3:
	comport  = sys.argv[1]
	baudRate = sys.argv[2]
else:
	comport  = sys.argv[1]
	# Setup the default baudrate.
	baudRate = 115200 #921600

READ_TIMEOUT = 15

def ByteToHex( ch ):
	try:
		ch = ord(ch)
	except:
		ch = 0
	return ch

def print_sep_line( ch ):
	line = ch * 80
	print(line, flush=True)

#----------------------------------------------

print("Image Reader Started")
print_sep_line('-')

retVal = comManager.init(comport, baudRate)
if retVal != 0:
	print ("comport open failed. Please check %s status\n" % comport);
	sys.exit()

while True:
	if ( comManager.find_sync() == 1 ):
		print ("\n\n***Sync word found***", flush=True)
		print ("Reading image bytes, please wait...", flush=True)

		# width
		arr = comManager.read(2)
		w = arr[0]*256 + arr[1]
		# height
		arr = comManager.read(2)
		h = arr[0]*256 + arr[1]

		pixelformat_len = comManager.read(1)
		pixelformat = comManager.read(pixelformat_len[0])

		arr = comManager.read(4)
		imageLen = arr[0]*256*256*256 + arr[1]*256*256 + arr[2]*256 + arr[3]

		print ("image Len: %d" % imageLen, flush=True);
		print('Image format is ' + pixelformat.decode('ASCII'))
		if ( imageLen > 0 ):
			image = bytearray()
			startTime = time.time();
			timeout = 0
			while (imageLen != len(image)):
				image += comManager.read(imageLen-len(image))
				print ("  Total Read Len:%d bytes" % len(image), flush=True)
				# check timeout
				if ( time.time() > (startTime + READ_TIMEOUT)):
					print("Test Failed: Timeout\n", flush=True);
					timeout = 1
					break

			if (timeout == 1):
				continue

			array_name = "INPUT_0"
			header_file = "received.h"	
			output_file = "output_image_received.png"
			
			input_chunk_size = 3  # 3 bytes (RGB)
			
			# Ensure the image data is a bytearray for manipulation
			if not isinstance(image, (bytes, bytearray)):
				print("Error: Input 'image' must be a bytes or bytearray object.")
				continue

			c_array_content = f"// This file was automatically generated by grab_image_hex.py\n"
			c_array_content += f"// Each 3-byte (24-bit) pixel was converted to a 4-byte (32-bit) ARGB value (0x00BBGGRR)\n\n"
			c_array_content += f"#define {array_name} {{ \\\n \t"
			
			# Determine the total number of 32-bit elements created
			num_elements = math.ceil(len(image) / input_chunk_size)
			elements_per_line = 8 # Print 8 elements per line for readability
			
			# Iterate through the image data in steps of 3 bytes
			for i in range(0, len(image), input_chunk_size):
				# Slice the 3 bytes for the current chunk (R, G, B)
				chunk_3_bytes = image[i : i + input_chunk_size]
				
				# Handle partial last chunk: Pad the end with 0x00 bytes 
				# This is a safe guard, but typically 24-bit data comes in multiples of 3.
				if len(chunk_3_bytes) < input_chunk_size:
					padding_needed = input_chunk_size - len(chunk_3_bytes)
					chunk_3_bytes += bytearray([0x00] * padding_needed)

				# Prepend the 0x00 byte to make it a 4-byte (32-bit) chunk
				# Structure: [0x00, B1, B2, B3] (Alpha=0, Red, Green, Blue)
				chunk_4_bytes = bytearray([0x00]) + chunk_3_bytes

				# Convert the 4 bytes into a single 32-bit integer (Big-Endian)
				# '>I' means Big-Endian (>) Unsigned Integer (I, 4 bytes)
				try:
					integer_value = struct.unpack('>I', chunk_4_bytes)[0] 
				except struct.error as e:
					# Should not happen if chunk_4_bytes always has 4 elements
					print(f"Error packing bytes at index {i}: {e}")
					continue
				
				# Format as 8-digit hex string and append to content
				c_array_content += f"0x{integer_value:08x}, "

				# Start a new line after every 'elements_per_line' elements
				if (i // input_chunk_size + 1) % elements_per_line == 0:
					c_array_content += "\\\n \t"

			# Remove the trailing comma and whitespace/newline
			c_array_content = c_array_content.rstrip(", \\\n \t")

			# Close the array declaration
			c_array_content += " \\\n};\n"

			# Write the content to the header file
			try:
				with open(header_file, 'w') as f:
					f.write(c_array_content)
				print(f"Successfully generated {header_file} with {num_elements} 32-bit elements.")
			except IOError as e:
				print(f"Error writing to file '{header_file}': {e}")

			image_saver.save_image_from_header(header_file, output_file, w, h)